#!/bin/bash

# Pre-commit hook that uses modular checkers
# All linting logic is now in .husky/lib/

# Get the directory of this script
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common functions and all checkers
# shellcheck disable=SC1091
source "${HOOK_DIR}/lib/common.sh"

# Source all checker modules
for checker in "${HOOK_DIR}"/lib/*-checker.sh; do
    if [ -f "$checker" ]; then
        # shellcheck source=/dev/null
        source "$checker"
    fi
done

# Track start time for summary
START_TIME=$(date +%s)

# Check for quick mode
QUICK_MODE=0
if [ "$PRE_COMMIT_QUICK" = "1" ]; then
    warn "Running in quick mode (syntax checks only)"
    QUICK_MODE=1
fi

# Allow skipping with environment variable
if [ "$SKIP_PRE_COMMIT" = "1" ]; then
    warn "Pre-commit checks skipped (SKIP_PRE_COMMIT=1)"
    exit 0
fi

# Emergency bypass file check
if [ -f ".git/BYPASS_PRECOMMIT" ]; then
    warn "Bypassing pre-commit (remove .git/BYPASS_PRECOMMIT to re-enable)"
    exit 0
fi

# Check if we're in a merge/rebase
check_merge_conflict() {
    if [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ]; then
        warn "Detected merge/rebase in progress"
        debug "Skipping pre-commit hooks during merge"
        exit 0
    fi
}

# Function to show summary and give review opportunity
show_summary() {
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))

    echo ""
    info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    header "Pre-commit Summary (${DURATION}s)"
    info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [ "$PARTIAL_STAGING_WARNING" -eq 1 ]; then
        echo ""
        warn "Warning: Some files were partially staged"
        debug "Auto-fixes were applied to entire files"
        debug "Review carefully before committing"
    fi

    if [ "$FIXES_APPLIED" -eq 1 ]; then
        echo ""
        warn "Auto-fixes were applied and staged"
        echo ""
        debug "Review the changes:"
        echo "  git diff --cached     # See what will be committed"
        echo "  git diff              # See any remaining unstaged changes"
        echo ""
        debug "Options:"
        echo "  git commit            # Accept fixes and commit"
        echo "  git reset             # Unstage everything to review manually"
        echo "  git reset <file>      # Unstage specific file"
    fi

    if [ "$ERRORS_FOUND" -eq 1 ]; then
        echo ""
        error "Some checks failed and need manual fixes"
        echo ""
        debug "To troubleshoot:"
        echo "  git diff --cached     # Review staged changes"
        echo "  git status            # Check file states"
        echo ""
        debug "To bypass hooks (use sparingly):"
        echo "  git commit --no-verify"
        echo "  touch .git/BYPASS_PRECOMMIT     # For persistent bypass"
        return 1
    else
        echo ""
        success "All checks passed!"
        if [ $QUICK_MODE -eq 1 ]; then
            debug "Note: Quick mode was enabled - some checks were skipped"
        fi
        return 0
    fi
}

# Function to run linters in parallel
run_linters_parallel() {
    local pids=""
    local results_dir
    results_dir=$(mktemp -d)

    # Start all linters in background
    debug "Running linters in parallel..."

    (
        check_markdown
        echo $? >"$results_dir/markdown"
    ) &
    pids="$pids $!"
    (
        check_typescript
        echo $? >"$results_dir/typescript"
    ) &
    pids="$pids $!"
    (
        check_rust
        echo $? >"$results_dir/rust"
    ) &
    pids="$pids $!"
    (
        check_python
        echo $? >"$results_dir/python"
    ) &
    pids="$pids $!"
    (
        check_shell
        echo $? >"$results_dir/shell"
    ) &
    pids="$pids $!"

    # Wait for all linters to complete
    for pid in $pids; do
        wait "$pid"
    done

    # Aggregate results
    local total_errors=0
    for result_file in "$results_dir"/*; do
        if [ -f "$result_file" ]; then
            local exit_code
            exit_code=$(cat "$result_file")
            if [ "$exit_code" -ne 0 ]; then
                total_errors=$((total_errors + 1))
            fi
        fi
    done

    # Clean up
    rm -rf "$results_dir"

    # Return non-zero if any linter failed
    [ $total_errors -eq 0 ]
}

# Main execution
header "Running pre-commit checks..."
debug "Tip: Use PRE_COMMIT_QUICK=1 for faster commits, PRE_COMMIT_SEQUENTIAL=1 for sequential mode"
echo ""

check_merge_conflict
activate_venv

# Check if sequential mode is explicitly requested
if [ "$PRE_COMMIT_SEQUENTIAL" = "1" ]; then
    # Run linters sequentially
    check_markdown
    check_typescript
    check_rust
    check_python
    check_shell
else
    # Run linters in parallel (default)
    run_linters_parallel
fi

# Show summary and exit
show_summary
exit $?
