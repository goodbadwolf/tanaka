#!/bin/bash

C_RED="\033[0;31m"
C_YELLOW="\033[1;33m"
C_BLUE="\033[0;34m"
C_GREEN="\033[0;32m"
C_GRAY="\033[0;90m"
C_BOLD="\033[1m"
C_NC="\033[0m"

# Track if we made any auto-fixes
FIXES_APPLIED=0
ERRORS_FOUND=0
START_TIME=$(date +%s)
PARTIAL_STAGING_WARNING=0

# Check for quick mode
QUICK_MODE=0
if [ "$PRE_COMMIT_QUICK" = "1" ]; then
    echo "${C_YELLOW}⚡ Running in quick mode (syntax checks only)${C_NC}"
    QUICK_MODE=1
fi

# Allow skipping with environment variable
if [ "$SKIP_PRE_COMMIT" = "1" ]; then
    echo "${C_YELLOW}⚠️  Pre-commit checks skipped (SKIP_PRE_COMMIT=1)${C_NC}"
    exit 0
fi

# Emergency bypass file check
if [ -f ".git/BYPASS_PRECOMMIT" ]; then
    echo "${C_YELLOW}⚠️  Bypassing pre-commit (remove .git/BYPASS_PRECOMMIT to re-enable)${C_NC}"
    exit 0
fi

# Function to log stage start
log_stage_start() {
    local stage_name="$1"
    echo ""
    echo "${C_BOLD}Stage ${stage_name}: Started${C_NC}"
    echo "${C_GRAY}────────────────────────────────────────${C_NC}"
}

# Function to log stage skip
log_stage_skip() {
    local stage_name="$1"
    local reason="$2"
    echo ""
    echo "${C_BOLD}Stage ${stage_name}: Skipped${C_NC} ${C_GRAY}(${reason})${C_NC}"
}

# Function to log stage finish
log_stage_finish() {
    local stage_name="$1"
    local result="$2"
    local color="${C_GREEN}"

    if [ "$result" = "FAILED" ]; then
        color="${C_RED}"
    elif [ "$result" = "FIXED" ]; then
        color="${C_YELLOW}"
    fi

    echo "${C_GRAY}────────────────────────────────────────${C_NC}"
    echo "${C_BOLD}Stage ${stage_name}: Finished with ${color}${result}${C_NC}"
}

# Check if we're in a merge/rebase
check_merge_conflict() {
    if [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ]; then
        echo "${C_YELLOW}⚠️  Detected merge/rebase in progress${C_NC}"
        echo "${C_GRAY}Skipping pre-commit hooks during merge${C_NC}"
        exit 0
    fi
}

# Check if tanaka.py itself is being modified
check_tanaka_py_modified() {
    if git diff --cached --name-only | grep -q "scripts/tanaka.py\|scripts/tasks/.*\.py"; then
        echo ""
        echo "${C_YELLOW}⚠️  Warning: Python scripts are being modified${C_NC}"
        echo "${C_GRAY}Some linting checks may behave unexpectedly${C_NC}"
        echo "${C_GRAY}Consider running checks manually after commit${C_NC}"
        return 0
    fi
    return 1
}

# Check if file is partially staged
check_partial_staging() {
    local file="$1"
    # Check if file has both staged and unstaged changes
    if git diff --cached --name-only | grep -q "^$file$" &&
        git diff --name-only | grep -q "^$file$"; then
        return 0 # Partially staged
    fi
    return 1 # Fully staged or not staged
}

# Warn about partially staged files
warn_partial_staging() {
    local files="$1"
    local any_partial=0

    for file in $files; do
        if check_partial_staging "$file"; then
            if [ $any_partial -eq 0 ]; then
                echo "${C_YELLOW}⚠️  Partially staged files detected:${C_NC}"
                any_partial=1
                PARTIAL_STAGING_WARNING=1
            fi
            echo "${C_GRAY}   - $file${C_NC}"
        fi
    done

    if [ $any_partial -eq 1 ]; then
        echo "${C_GRAY}   Auto-fixes will affect the entire file${C_NC}"
    fi
}

activate_venv() {
    if [ -z "$VIRTUAL_ENV" ]; then
        if [ -f .venv/bin/activate ]; then
            # shellcheck disable=SC1091
            . .venv/bin/activate || {
                echo "${C_RED}Failed to activate virtual environment${C_NC}"
                exit 1
            }
        fi
    fi
}

# Function to auto-stage fixed files
auto_stage_fixes() {
    local files="$1"
    local file_type="$2"

    if [ -n "$files" ]; then
        echo "${C_GREEN}Auto-staging fixed ${file_type} files...${C_NC}"
        echo "$files" | xargs git add
        FIXES_APPLIED=1
    fi
}

# Check if a file has unstaged changes
has_unstaged_changes() {
    local file="$1"
    git diff --quiet "$file" 2>/dev/null
    return $?
}

# Source shell linting function if it exists
if [ -f "$(dirname "$0")/lint-shell.sh" ]; then
    # shellcheck disable=SC1091
    . "$(dirname "$0")/lint-shell.sh"
fi


lint_markdown() {
    # Check if any markdown files are staged
    MD_STAGED=$(git diff --cached --name-only --diff-filter=ACM | grep '\.md$' | grep -v "repomix-output.txt.md" | grep -v "MIGRATION" | grep -v "TESTING-UPGRADE.md")

    if [ -z "$MD_STAGED" ]; then
        log_stage_skip "Markdown Linting" "no markdown files staged"
        return 0
    fi

    log_stage_start "Markdown Linting"

    # Show file count warning if many files
    local file_count=$(echo "$MD_STAGED" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        echo "${C_YELLOW}⚠️  Linting $file_count markdown files (this may take a moment)${C_NC}"
    fi

    # Check for partially staged files
    warn_partial_staging "$MD_STAGED"

    # Quick mode - just check if files exist
    if [ $QUICK_MODE -eq 1 ]; then
        echo "${C_GRAY}Quick mode: Skipping markdown linting${C_NC}"
        log_stage_finish "Markdown Linting" "SKIPPED"
        return 0
    fi

    TANAKA_PY_MODIFIED=$(
        check_tanaka_py_modified
        echo $?
    )

    if [ $TANAKA_PY_MODIFIED -eq 0 ]; then
        echo "${C_YELLOW}Using basic markdown check due to script modifications${C_NC}"
        # Fallback to basic check
        if command -v pymarkdownlnt >/dev/null 2>&1; then
            if pymarkdownlnt scan $MD_STAGED; then
                log_stage_finish "Markdown Linting" "PASSED"
                return 0
            else
                log_stage_finish "Markdown Linting" "FAILED"
                ERRORS_FOUND=1
                return 1
            fi
        else
            echo "${C_GRAY}pymarkdownlnt not found, skipping markdown check${C_NC}"
            log_stage_finish "Markdown Linting" "SKIPPED"
            return 0
        fi
    fi

    # Normal path using tanaka.py
    echo "${C_GRAY}Attempting to auto-fix markdown issues...${C_NC}"
    if python3 scripts/tanaka.py lint --markdown --fix >/dev/null 2>&1; then
        # Check which files were actually modified
        FIXED_FILES=""
        for file in $MD_STAGED; do
            if ! has_unstaged_changes "$file"; then
                FIXED_FILES="$FIXED_FILES $file"
            fi
        done

        if [ -n "$FIXED_FILES" ]; then
            auto_stage_fixes "$FIXED_FILES" "markdown"
            log_stage_finish "Markdown Linting" "FIXED"
        else
            log_stage_finish "Markdown Linting" "PASSED"
        fi
        return 0
    else
        # If auto-fix failed, run without fix to show errors
        echo "${C_YELLOW}Auto-fix failed, showing errors:${C_NC}"
        python3 scripts/tanaka.py lint --markdown || {
            log_stage_finish "Markdown Linting" "FAILED"
            ERRORS_FOUND=1
            return 1
        }
    fi
}

lint_typescript() {
    # Check if any TypeScript files are staged
    STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx)$' | grep '^extension/')

    if [ -z "$STAGED_TS_FILES" ]; then
        log_stage_skip "TypeScript Linting" "no TypeScript files staged"
        return 0
    fi

    if [ ! -d "extension" ]; then
        log_stage_skip "TypeScript Linting" "extension directory not found"
        return 0
    fi

    log_stage_start "TypeScript Linting"

    # Show file count warning if many files
    local file_count=$(echo "$STAGED_TS_FILES" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        echo "${C_YELLOW}⚠️  Linting $file_count TypeScript files (this may take a moment)${C_NC}"
    fi

    # Check for partially staged files
    warn_partial_staging "$STAGED_TS_FILES"

    cd extension || return 1

    # Convert paths for the extension directory context
    RELATIVE_FILES=$(echo "$STAGED_TS_FILES" | sed 's|^extension/||g')

    if [ $QUICK_MODE -eq 1 ]; then
        echo "${C_GRAY}Quick mode: Running TypeScript compiler check only${C_NC}"
        if pnpm exec tsc --noEmit; then
            cd ..
            log_stage_finish "TypeScript Linting" "PASSED"
            return 0
        else
            cd ..
            log_stage_finish "TypeScript Linting" "FAILED"
            ERRORS_FOUND=1
            return 1
        fi
    fi

    echo "${C_GRAY}Running Prettier...${C_NC}"
    PRETTIER_FAILED=0
    echo "$RELATIVE_FILES" | xargs pnpm exec prettier --write || PRETTIER_FAILED=1

    echo "${C_GRAY}Running ESLint...${C_NC}"
    ESLINT_FAILED=0
    echo "$RELATIVE_FILES" | xargs pnpm exec eslint --fix || ESLINT_FAILED=1

    # Check which files were actually modified and stage them
    cd .. || return 1
    FIXED_FILES=""
    for file in $STAGED_TS_FILES; do
        if ! has_unstaged_changes "$file"; then
            FIXED_FILES="$FIXED_FILES $file"
        fi
    done

    if [ -n "$FIXED_FILES" ]; then
        auto_stage_fixes "$FIXED_FILES" "TypeScript"
    fi

    if [ $PRETTIER_FAILED -eq 1 ] || [ $ESLINT_FAILED -eq 1 ]; then
        log_stage_finish "TypeScript Linting" "FAILED"
        ERRORS_FOUND=1
        return 1
    elif [ -n "$FIXED_FILES" ]; then
        log_stage_finish "TypeScript Linting" "FIXED"
    else
        log_stage_finish "TypeScript Linting" "PASSED"
    fi

    return 0
}

lint_rust() {
    # Check if any Rust files are staged
    STAGED_RUST_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.rs$' | grep '^server/')

    if [ -z "$STAGED_RUST_FILES" ]; then
        log_stage_skip "Rust Linting" "no Rust files staged"
        return 0
    fi

    if [ ! -d "server" ]; then
        log_stage_skip "Rust Linting" "server directory not found"
        return 0
    fi

    log_stage_start "Rust Linting"

    # Show file count warning if many files
    local file_count=$(echo "$STAGED_RUST_FILES" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        echo "${C_YELLOW}⚠️  Linting $file_count Rust files (this may take a moment)${C_NC}"
    fi

    # Check for partially staged files
    warn_partial_staging "$STAGED_RUST_FILES"

    cd server || return 1

    # First run cargo fmt
    echo "${C_GRAY}Running cargo fmt...${C_NC}"
    if cargo fmt --all; then
        # Check which files were formatted
        cd .. || return 1
        FIXED_FILES=""
        for file in $STAGED_RUST_FILES; do
            if ! has_unstaged_changes "$file"; then
                FIXED_FILES="$FIXED_FILES $file"
            fi
        done

        if [ -n "$FIXED_FILES" ]; then
            auto_stage_fixes "$FIXED_FILES" "Rust"
        fi

        # In quick mode, skip clippy
        if [ $QUICK_MODE -eq 1 ]; then
            echo "${C_GRAY}Quick mode: Skipping cargo clippy${C_NC}"
            if [ -n "$FIXED_FILES" ]; then
                log_stage_finish "Rust Linting" "FIXED"
            else
                log_stage_finish "Rust Linting" "PASSED"
            fi
            return 0
        fi

        # Now run clippy to check for issues
        cd server || return 1
        echo "${C_GRAY}Running cargo clippy...${C_NC}"
        if cargo clippy --all-targets --all-features -- -D warnings; then
            cd .. || return 1
            if [ -n "$FIXED_FILES" ]; then
                log_stage_finish "Rust Linting" "FIXED"
            else
                log_stage_finish "Rust Linting" "PASSED"
            fi
            return 0
        else
            cd .. || return 1
            log_stage_finish "Rust Linting" "FAILED"
            echo "${C_YELLOW}Fix the clippy warnings before committing${C_NC}"
            ERRORS_FOUND=1
            return 1
        fi
    else
        cd .. || return 1
        log_stage_finish "Rust Linting" "FAILED"
        ERRORS_FOUND=1
        return 1
    fi
}

lint_python() {
    # Check if Python files are staged
    STAGED_PY_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$')

    if [ -z "$STAGED_PY_FILES" ]; then
        log_stage_skip "Python Linting" "no Python files staged"
        return 0
    fi

    log_stage_start "Python Linting"

    # Show file count warning if many files
    local file_count=$(echo "$STAGED_PY_FILES" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        echo "${C_YELLOW}⚠️  Linting $file_count Python files (this may take a moment)${C_NC}"
    fi

    # Check for partially staged files
    warn_partial_staging "$STAGED_PY_FILES"

    TANAKA_PY_MODIFIED=$(
        check_tanaka_py_modified
        echo $?
    )

    if [ $TANAKA_PY_MODIFIED -eq 0 ] || [ $QUICK_MODE -eq 1 ]; then
        if [ $TANAKA_PY_MODIFIED -eq 0 ]; then
            echo "${C_YELLOW}Running basic Python checks due to script modifications${C_NC}"
        else
            echo "${C_GRAY}Quick mode: Running syntax check only${C_NC}"
        fi

        # Just check syntax
        SYNTAX_ERROR=0
        for file in $STAGED_PY_FILES; do
            if ! python3 -m py_compile "$file" 2>/dev/null; then
                echo "${C_RED}Syntax error in $file${C_NC}"
                SYNTAX_ERROR=1
            fi
        done

        if [ $SYNTAX_ERROR -eq 1 ]; then
            log_stage_finish "Python Linting" "FAILED"
            ERRORS_FOUND=1
            return 1
        else
            log_stage_finish "Python Linting" "PASSED"
            return 0
        fi
    fi

    # Normal path
    echo "${C_GRAY}Running Python formatters...${C_NC}"

    # Run ruff with fix
    RUFF_FAILED=0
    echo "$STAGED_PY_FILES" | xargs uv run ruff check --fix || RUFF_FAILED=1

    # Run black
    BLACK_FAILED=0
    echo "$STAGED_PY_FILES" | xargs uv run black || BLACK_FAILED=1

    # Check which files were modified and stage them
    FIXED_FILES=""
    for file in $STAGED_PY_FILES; do
        if ! has_unstaged_changes "$file"; then
            FIXED_FILES="$FIXED_FILES $file"
        fi
    done

    if [ -n "$FIXED_FILES" ]; then
        auto_stage_fixes "$FIXED_FILES" "Python"
    fi

    if [ $RUFF_FAILED -eq 1 ] || [ $BLACK_FAILED -eq 1 ]; then
        log_stage_finish "Python Linting" "FAILED"
        ERRORS_FOUND=1
        return 1
    elif [ -n "$FIXED_FILES" ]; then
        log_stage_finish "Python Linting" "FIXED"
    else
        log_stage_finish "Python Linting" "PASSED"
    fi

    return 0
}

# Function to show summary and give review opportunity
show_summary() {
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))

    echo ""
    echo "${C_BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C_NC}"
    echo "${C_BOLD}Pre-commit Summary${C_NC} ${C_GRAY}(${DURATION}s)${C_NC}"
    echo "${C_BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C_NC}"

    if [ $PARTIAL_STAGING_WARNING -eq 1 ]; then
        echo ""
        echo "${C_YELLOW}⚠️  Warning: Some files were partially staged${C_NC}"
        echo "${C_GRAY}Auto-fixes were applied to entire files${C_NC}"
        echo "${C_GRAY}Review carefully before committing${C_NC}"
    fi

    if [ $FIXES_APPLIED -eq 1 ]; then
        echo ""
        echo "${C_YELLOW}⚡ Auto-fixes were applied and staged${C_NC}"
        echo ""
        echo "${C_GRAY}Review the changes:${C_NC}"
        echo "  ${C_GREEN}git diff --cached${C_NC}     ${C_GRAY}# See what will be committed${C_NC}"
        echo "  ${C_GREEN}git diff${C_NC}            ${C_GRAY}# See any remaining unstaged changes${C_NC}"
        echo ""
        echo "${C_GRAY}Options:${C_NC}"
        echo "  ${C_GREEN}git commit${C_NC}          ${C_GRAY}# Accept fixes and commit${C_NC}"
        echo "  ${C_YELLOW}git reset${C_NC}           ${C_GRAY}# Unstage everything to review manually${C_NC}"
        echo "  ${C_YELLOW}git reset <file>${C_NC}    ${C_GRAY}# Unstage specific file${C_NC}"
    fi

    if [ $ERRORS_FOUND -eq 1 ]; then
        echo ""
        echo "${C_RED}✗ Some checks failed and need manual fixes${C_NC}"
        echo ""
        echo "${C_GRAY}To troubleshoot:${C_NC}"
        echo "  ${C_GREEN}git diff --cached${C_NC}   ${C_GRAY}# Review staged changes${C_NC}"
        echo "  ${C_GREEN}git status${C_NC}          ${C_GRAY}# Check file states${C_NC}"
        echo ""
        echo "${C_GRAY}To bypass hooks (use sparingly):${C_NC}"
        echo "  ${C_YELLOW}git commit --no-verify${C_NC}"
        echo "  ${C_YELLOW}touch .git/BYPASS_PRECOMMIT${C_NC} ${C_GRAY}# For persistent bypass${C_NC}"
        return 1
    else
        echo ""
        echo "${C_GREEN}✓ All checks passed!${C_NC}"
        if [ $QUICK_MODE -eq 1 ]; then
            echo "${C_GRAY}Note: Quick mode was enabled - some checks were skipped${C_NC}"
        fi
        return 0
    fi
}

# Main execution
echo "${C_BOLD}Running pre-commit checks...${C_NC}"
echo "${C_GRAY}Tip: Use PRE_COMMIT_QUICK=1 for faster commits${C_NC}"
echo ""

check_merge_conflict
activate_venv

# Function to run linters in parallel
run_linters_parallel() {
    local pids=""
    local results_dir
    results_dir=$(mktemp -d)
    
    # Start all linters in background
    echo "${C_GRAY}Running linters in parallel...${C_NC}"
    
    (lint_markdown; echo $? > "$results_dir/markdown") & pids="$pids $!"
    (lint_typescript; echo $? > "$results_dir/typescript") & pids="$pids $!"
    (lint_rust; echo $? > "$results_dir/rust") & pids="$pids $!"
    (lint_python; echo $? > "$results_dir/python") & pids="$pids $!"
    # Run shell linting if function exists
    if type lint_shell >/dev/null 2>&1; then
        (lint_shell; echo $? > "$results_dir/shell") & pids="$pids $!"
    fi
    
    # Wait for all linters to complete
    for pid in $pids; do
        wait "$pid"
    done
    
    # Aggregate results
    local total_errors=0
    for result_file in "$results_dir"/*; do
        if [ -f "$result_file" ]; then
            local exit_code
            exit_code=$(cat "$result_file")
            if [ "$exit_code" -ne 0 ]; then
                total_errors=$((total_errors + 1))
            fi
        fi
    done
    
    # Clean up
    rm -rf "$results_dir"
    
    # Return non-zero if any linter failed
    [ $total_errors -eq 0 ]
}

# Check if parallel mode is enabled via environment variable
if [ "$PRE_COMMIT_PARALLEL" = "1" ]; then
    run_linters_parallel
else
    # Run linters sequentially (default)
    lint_markdown
    lint_typescript
    lint_rust
    lint_python
    # Run shell linting if function exists
    if type lint_shell >/dev/null 2>&1; then
        lint_shell
    fi
fi

# Show summary and exit
show_summary
exit $?
