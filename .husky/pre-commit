#!/bin/bash

# Emit function for color output that respects terminal capabilities
emit() {
    local color="$1"
    local message="$2"
    
    # Check if stdout is a terminal
    if [ -t 1 ]; then
        # Terminal - use color
        case "$color" in
            red)     echo -e "\033[0;31m${message}\033[0m" ;;
            green)   echo -e "\033[0;32m${message}\033[0m" ;;
            yellow)  echo -e "\033[1;33m${message}\033[0m" ;;
            blue)    echo -e "\033[0;34m${message}\033[0m" ;;
            gray)    echo -e "\033[0;90m${message}\033[0m" ;;
            bold)    echo -e "\033[1m${message}\033[0m" ;;
            *)       echo "$message" ;;  # No color for unknown
        esac
    else
        # Not a terminal (pipe, file, etc) - no color
        echo "$message"
    fi
}

# Logging functions
debug() { emit "gray" "$1"; }
info() { emit "blue" "$1"; }
warn() { emit "yellow" "$1"; }
error() { emit "red" "$1"; }
success() { emit "green" "$1"; }
header() { emit "bold" "$1"; }

# Track if we made any auto-fixes
FIXES_APPLIED=0
ERRORS_FOUND=0
START_TIME=$(date +%s)
PARTIAL_STAGING_WARNING=0

# Check for quick mode
QUICK_MODE=0
if [ "$PRE_COMMIT_QUICK" = "1" ]; then
    warn "Running in quick mode (syntax checks only)"
    QUICK_MODE=1
fi

# Allow skipping with environment variable
if [ "$SKIP_PRE_COMMIT" = "1" ]; then
    warn "Pre-commit checks skipped (SKIP_PRE_COMMIT=1)"
    exit 0
fi

# Emergency bypass file check
if [ -f ".git/BYPASS_PRECOMMIT" ]; then
    warn "Bypassing pre-commit (remove .git/BYPASS_PRECOMMIT to re-enable)"
    exit 0
fi

# Function to log stage start
log_stage_start() {
    local stage_name="$1"
    echo ""
    header "Stage ${stage_name}: Started"
    debug "────────────────────────────────────────"
}

# Function to log stage skip
log_stage_skip() {
    local stage_name="$1"
    local reason="$2"
    echo ""
    header "Stage ${stage_name}: Skipped"
    debug "(${reason})"
}

# Function to log stage finish
log_stage_finish() {
    local stage_name="$1"
    local result="$2"

    debug "────────────────────────────────────────"
    if [ "$result" = "FAILED" ]; then
        error "Stage ${stage_name}: Finished with ${result}"
    elif [ "$result" = "FIXED" ]; then
        warn "Stage ${stage_name}: Finished with ${result}"
    else
        success "Stage ${stage_name}: Finished with ${result}"
    fi
}

# Check if we're in a merge/rebase
check_merge_conflict() {
    if [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ]; then
        warn "Detected merge/rebase in progress"
        debug "Skipping pre-commit hooks during merge"
        exit 0
    fi
}

# Check if tanaka.py itself is being modified
check_tanaka_py_modified() {
    if git diff --cached --name-only | grep -q "scripts/tanaka.py\|scripts/tasks/.*\.py"; then
        echo ""
        warn "Warning: Python scripts are being modified"
        debug "Some linting checks may behave unexpectedly"
        debug "Consider running checks manually after commit"
        return 0
    fi
    return 1
}

# Check if file is partially staged
check_partial_staging() {
    local file="$1"
    # Check if file has both staged and unstaged changes
    if git diff --cached --name-only | grep -q "^$file$" &&
        git diff --name-only | grep -q "^$file$"; then
        return 0 # Partially staged
    fi
    return 1 # Fully staged or not staged
}

# Warn about partially staged files
warn_partial_staging() {
    local files="$1"
    local any_partial=0

    for file in $files; do
        if check_partial_staging "$file"; then
            if [ $any_partial -eq 0 ]; then
                warn "Partially staged files detected:"
                any_partial=1
                PARTIAL_STAGING_WARNING=1
            fi
            debug "   - $file"
        fi
    done

    if [ $any_partial -eq 1 ]; then
        debug "   Auto-fixes will affect the entire file"
    fi
}

activate_venv() {
    if [ -z "$VIRTUAL_ENV" ]; then
        if [ -f .venv/bin/activate ]; then
            # shellcheck disable=SC1091
            . .venv/bin/activate || {
                error "Failed to activate virtual environment"
                exit 1
            }
        fi
    fi
}

# Function to auto-stage fixed files
auto_stage_fixes() {
    local files="$1"
    local file_type="$2"

    if [ -n "$files" ]; then
        success "Auto-staging fixed ${file_type} files..."
        echo "$files" | xargs git add
        FIXES_APPLIED=1
    fi
}

# Check if a file has unstaged changes
has_unstaged_changes() {
    local file="$1"
    git diff --quiet "$file" 2>/dev/null
    return $?
}

# Source shell linting function if it exists
if [ -f "$(dirname "$0")/lint-shell.sh" ]; then
    # shellcheck disable=SC1091
    . "$(dirname "$0")/lint-shell.sh"
fi


lint_markdown() {
    # Check if any markdown files are staged
    MD_STAGED=$(git diff --cached --name-only --diff-filter=ACM | grep '\.md$' | grep -v "repomix-output.txt.md" | grep -v "MIGRATION" | grep -v "TESTING-UPGRADE.md")

    if [ -z "$MD_STAGED" ]; then
        log_stage_skip "Markdown Linting" "no markdown files staged"
        return 0
    fi

    log_stage_start "Markdown Linting"

    # Show file count warning if many files
    local file_count=$(echo "$MD_STAGED" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        warn "Linting $file_count markdown files (this may take a moment)"
    fi

    # Check for partially staged files
    warn_partial_staging "$MD_STAGED"

    # Quick mode - just check if files exist
    if [ $QUICK_MODE -eq 1 ]; then
        debug "Quick mode: Skipping markdown linting"
        log_stage_finish "Markdown Linting" "SKIPPED"
        return 0
    fi

    TANAKA_PY_MODIFIED=$(
        check_tanaka_py_modified
        echo $?
    )

    if [ $TANAKA_PY_MODIFIED -eq 0 ]; then
        warn "Using basic markdown check due to script modifications"
        # Fallback to basic check
        if command -v pymarkdownlnt >/dev/null 2>&1; then
            if pymarkdownlnt scan $MD_STAGED; then
                log_stage_finish "Markdown Linting" "PASSED"
                return 0
            else
                log_stage_finish "Markdown Linting" "FAILED"
                ERRORS_FOUND=1
                return 1
            fi
        else
            debug "pymarkdownlnt not found, skipping markdown check"
            log_stage_finish "Markdown Linting" "SKIPPED"
            return 0
        fi
    fi

    # Normal path using tanaka.py
    debug "Attempting to auto-fix markdown issues..."
    if python3 scripts/tanaka.py lint --markdown --fix >/dev/null 2>&1; then
        # Check which files were actually modified
        FIXED_FILES=""
        for file in $MD_STAGED; do
            if ! has_unstaged_changes "$file"; then
                FIXED_FILES="$FIXED_FILES $file"
            fi
        done

        if [ -n "$FIXED_FILES" ]; then
            auto_stage_fixes "$FIXED_FILES" "markdown"
            log_stage_finish "Markdown Linting" "FIXED"
        else
            log_stage_finish "Markdown Linting" "PASSED"
        fi
        return 0
    else
        # If auto-fix failed, run without fix to show errors
        warn "Auto-fix failed, showing errors:"
        python3 scripts/tanaka.py lint --markdown || {
            log_stage_finish "Markdown Linting" "FAILED"
            ERRORS_FOUND=1
            return 1
        }
    fi
}

lint_typescript() {
    # Check if any TypeScript files are staged
    STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx)$' | grep '^extension/')

    if [ -z "$STAGED_TS_FILES" ]; then
        log_stage_skip "TypeScript Linting" "no TypeScript files staged"
        return 0
    fi

    if [ ! -d "extension" ]; then
        log_stage_skip "TypeScript Linting" "extension directory not found"
        return 0
    fi

    log_stage_start "TypeScript Linting"

    # Show file count warning if many files
    local file_count=$(echo "$STAGED_TS_FILES" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        warn "Linting $file_count TypeScript files (this may take a moment)"
    fi

    # Check for partially staged files
    warn_partial_staging "$STAGED_TS_FILES"

    cd extension || return 1

    # Convert paths for the extension directory context
    RELATIVE_FILES=$(echo "$STAGED_TS_FILES" | sed 's|^extension/||g')

    if [ $QUICK_MODE -eq 1 ]; then
        debug "Quick mode: Running TypeScript compiler check only"
        if pnpm exec tsc --noEmit; then
            cd ..
            log_stage_finish "TypeScript Linting" "PASSED"
            return 0
        else
            cd ..
            log_stage_finish "TypeScript Linting" "FAILED"
            ERRORS_FOUND=1
            return 1
        fi
    fi

    debug "Running Prettier..."
    PRETTIER_FAILED=0
    echo "$RELATIVE_FILES" | xargs pnpm exec prettier --write || PRETTIER_FAILED=1

    debug "Running ESLint..."
    ESLINT_FAILED=0
    echo "$RELATIVE_FILES" | xargs pnpm exec eslint --fix || ESLINT_FAILED=1

    # Check which files were actually modified and stage them
    cd .. || return 1
    FIXED_FILES=""
    for file in $STAGED_TS_FILES; do
        if ! has_unstaged_changes "$file"; then
            FIXED_FILES="$FIXED_FILES $file"
        fi
    done

    if [ -n "$FIXED_FILES" ]; then
        auto_stage_fixes "$FIXED_FILES" "TypeScript"
    fi

    if [ $PRETTIER_FAILED -eq 1 ] || [ $ESLINT_FAILED -eq 1 ]; then
        log_stage_finish "TypeScript Linting" "FAILED"
        ERRORS_FOUND=1
        return 1
    elif [ -n "$FIXED_FILES" ]; then
        log_stage_finish "TypeScript Linting" "FIXED"
    else
        log_stage_finish "TypeScript Linting" "PASSED"
    fi

    return 0
}

lint_rust() {
    # Check if any Rust files are staged
    STAGED_RUST_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.rs$' | grep '^server/')

    if [ -z "$STAGED_RUST_FILES" ]; then
        log_stage_skip "Rust Linting" "no Rust files staged"
        return 0
    fi

    if [ ! -d "server" ]; then
        log_stage_skip "Rust Linting" "server directory not found"
        return 0
    fi

    log_stage_start "Rust Linting"

    # Show file count warning if many files
    local file_count=$(echo "$STAGED_RUST_FILES" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        warn "Linting $file_count Rust files (this may take a moment)"
    fi

    # Check for partially staged files
    warn_partial_staging "$STAGED_RUST_FILES"

    cd server || return 1

    # First run cargo fmt
    debug "Running cargo fmt..."
    if cargo fmt --all; then
        # Check which files were formatted
        cd .. || return 1
        FIXED_FILES=""
        for file in $STAGED_RUST_FILES; do
            if ! has_unstaged_changes "$file"; then
                FIXED_FILES="$FIXED_FILES $file"
            fi
        done

        if [ -n "$FIXED_FILES" ]; then
            auto_stage_fixes "$FIXED_FILES" "Rust"
        fi

        # In quick mode, skip clippy
        if [ $QUICK_MODE -eq 1 ]; then
            debug "Quick mode: Skipping cargo clippy"
            if [ -n "$FIXED_FILES" ]; then
                log_stage_finish "Rust Linting" "FIXED"
            else
                log_stage_finish "Rust Linting" "PASSED"
            fi
            return 0
        fi

        # Now run clippy to check for issues
        cd server || return 1
        debug "Running cargo clippy..."
        if cargo clippy --all-targets --all-features -- -D warnings; then
            cd .. || return 1
            if [ -n "$FIXED_FILES" ]; then
                log_stage_finish "Rust Linting" "FIXED"
            else
                log_stage_finish "Rust Linting" "PASSED"
            fi
            return 0
        else
            cd .. || return 1
            log_stage_finish "Rust Linting" "FAILED"
            warn "Fix the clippy warnings before committing"
            ERRORS_FOUND=1
            return 1
        fi
    else
        cd .. || return 1
        log_stage_finish "Rust Linting" "FAILED"
        ERRORS_FOUND=1
        return 1
    fi
}

lint_python() {
    # Check if Python files are staged
    STAGED_PY_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$')

    if [ -z "$STAGED_PY_FILES" ]; then
        log_stage_skip "Python Linting" "no Python files staged"
        return 0
    fi

    log_stage_start "Python Linting"

    # Show file count warning if many files
    local file_count=$(echo "$STAGED_PY_FILES" | wc -w | tr -d ' ')
    if [ "$file_count" -gt 20 ]; then
        warn "Linting $file_count Python files (this may take a moment)"
    fi

    # Check for partially staged files
    warn_partial_staging "$STAGED_PY_FILES"

    TANAKA_PY_MODIFIED=$(
        check_tanaka_py_modified
        echo $?
    )

    if [ $TANAKA_PY_MODIFIED -eq 0 ] || [ $QUICK_MODE -eq 1 ]; then
        if [ $TANAKA_PY_MODIFIED -eq 0 ]; then
            warn "Running basic Python checks due to script modifications"
        else
            debug "Quick mode: Running syntax check only"
        fi

        # Just check syntax
        SYNTAX_ERROR=0
        for file in $STAGED_PY_FILES; do
            if ! python3 -m py_compile "$file" 2>/dev/null; then
                error "Syntax error in $file"
                SYNTAX_ERROR=1
            fi
        done

        if [ $SYNTAX_ERROR -eq 1 ]; then
            log_stage_finish "Python Linting" "FAILED"
            ERRORS_FOUND=1
            return 1
        else
            log_stage_finish "Python Linting" "PASSED"
            return 0
        fi
    fi

    # Normal path
    debug "Running Python formatters..."

    # Run ruff with fix
    RUFF_FAILED=0
    echo "$STAGED_PY_FILES" | xargs uv run ruff check --fix || RUFF_FAILED=1

    # Run black
    BLACK_FAILED=0
    echo "$STAGED_PY_FILES" | xargs uv run black || BLACK_FAILED=1

    # Check which files were modified and stage them
    FIXED_FILES=""
    for file in $STAGED_PY_FILES; do
        if ! has_unstaged_changes "$file"; then
            FIXED_FILES="$FIXED_FILES $file"
        fi
    done

    if [ -n "$FIXED_FILES" ]; then
        auto_stage_fixes "$FIXED_FILES" "Python"
    fi

    if [ $RUFF_FAILED -eq 1 ] || [ $BLACK_FAILED -eq 1 ]; then
        log_stage_finish "Python Linting" "FAILED"
        ERRORS_FOUND=1
        return 1
    elif [ -n "$FIXED_FILES" ]; then
        log_stage_finish "Python Linting" "FIXED"
    else
        log_stage_finish "Python Linting" "PASSED"
    fi

    return 0
}

# Function to show summary and give review opportunity
show_summary() {
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))

    echo ""
    info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    header "Pre-commit Summary (${DURATION}s)"
    info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [ $PARTIAL_STAGING_WARNING -eq 1 ]; then
        echo ""
        warn "Warning: Some files were partially staged"
        debug "Auto-fixes were applied to entire files"
        debug "Review carefully before committing"
    fi

    if [ $FIXES_APPLIED -eq 1 ]; then
        echo ""
        warn "Auto-fixes were applied and staged"
        echo ""
        debug "Review the changes:"
        echo "  git diff --cached     # See what will be committed"
        echo "  git diff              # See any remaining unstaged changes"
        echo ""
        debug "Options:"
        echo "  git commit            # Accept fixes and commit"
        echo "  git reset             # Unstage everything to review manually"
        echo "  git reset <file>      # Unstage specific file"
    fi

    if [ $ERRORS_FOUND -eq 1 ]; then
        echo ""
        error "Some checks failed and need manual fixes"
        echo ""
        debug "To troubleshoot:"
        echo "  git diff --cached     # Review staged changes"
        echo "  git status            # Check file states"
        echo ""
        debug "To bypass hooks (use sparingly):"
        echo "  git commit --no-verify"
        echo "  touch .git/BYPASS_PRECOMMIT     # For persistent bypass"
        return 1
    else
        echo ""
        success "All checks passed!"
        if [ $QUICK_MODE -eq 1 ]; then
            debug "Note: Quick mode was enabled - some checks were skipped"
        fi
        return 0
    fi
}

# Main execution
header "Running pre-commit checks..."
debug "Tip: Use PRE_COMMIT_QUICK=1 for faster commits"
echo ""

check_merge_conflict
activate_venv

# Function to run linters in parallel
run_linters_parallel() {
    local pids=""
    local results_dir
    results_dir=$(mktemp -d)
    
    # Start all linters in background
    debug "Running linters in parallel..."
    
    (lint_markdown; echo $? > "$results_dir/markdown") & pids="$pids $!"
    (lint_typescript; echo $? > "$results_dir/typescript") & pids="$pids $!"
    (lint_rust; echo $? > "$results_dir/rust") & pids="$pids $!"
    (lint_python; echo $? > "$results_dir/python") & pids="$pids $!"
    # Run shell linting if function exists
    if type lint_shell >/dev/null 2>&1; then
        (lint_shell; echo $? > "$results_dir/shell") & pids="$pids $!"
    fi
    
    # Wait for all linters to complete
    for pid in $pids; do
        wait "$pid"
    done
    
    # Aggregate results
    local total_errors=0
    for result_file in "$results_dir"/*; do
        if [ -f "$result_file" ]; then
            local exit_code
            exit_code=$(cat "$result_file")
            if [ "$exit_code" -ne 0 ]; then
                total_errors=$((total_errors + 1))
            fi
        fi
    done
    
    # Clean up
    rm -rf "$results_dir"
    
    # Return non-zero if any linter failed
    [ $total_errors -eq 0 ]
}

# Check if parallel mode is enabled via environment variable
if [ "$PRE_COMMIT_PARALLEL" = "1" ]; then
    run_linters_parallel
else
    # Run linters sequentially (default)
    lint_markdown
    lint_typescript
    lint_rust
    lint_python
    # Run shell linting if function exists
    if type lint_shell >/dev/null 2>&1; then
        lint_shell
    fi
fi

# Show summary and exit
show_summary
exit $?
