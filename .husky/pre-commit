#!/bin/bash
set +e  # Don't exit on error - we handle errors explicitly
#
# Tanaka Pre-commit Hook
# ======================
#
# Ensures code quality by running linters and formatters before each commit.
# Uses modular checker scripts in .husky/lib/ for each language.
#
# Quick Usage:
# ------------
# git commit                      # Normal mode (parallel, with auto-fix)
# PRE_COMMIT_QUICK=1 git commit   # Quick mode (syntax only, no auto-fix)
# git commit --no-verify          # Skip all checks (emergency use)
#
# Dependencies:
# -------------
# All tools installed via: uv run scripts/tanaka.py setup-dev
# See individual checker files in .husky/lib/ for specific requirements.
#

# Get the directory of this script
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common functions and all checkers
# shellcheck disable=SC1091
source "${HOOK_DIR}/lib/common.sh"

# Source all checker modules
for checker in "${HOOK_DIR}"/lib/*-checker.sh; do
    if [ -f "$checker" ]; then
        # shellcheck source=/dev/null
        source "$checker"
    fi
done

# Track start time for summary
START_TIME=$(date +%s)

# Check for quick mode
QUICK_MODE=0
if [ "$PRE_COMMIT_QUICK" = "1" ]; then
    warn "Running in quick mode (syntax checks only)"
    QUICK_MODE=1
fi

# Allow skipping with environment variable
if [ "$SKIP_PRE_COMMIT" = "1" ]; then
    warn "Pre-commit checks skipped (SKIP_PRE_COMMIT=1)"
    exit 0
fi

# Emergency bypass file check
if [ -f ".git/BYPASS_PRECOMMIT" ]; then
    warn "Bypassing pre-commit (remove .git/BYPASS_PRECOMMIT to re-enable)"
    exit 0
fi

check_merge_conflict() {
    # Skip pre-commit hooks during merge/rebase operations
    # These operations have their own conflict resolution process
    if [ -f .git/MERGE_HEAD ] || [ -d .git/rebase-merge ] || [ -d .git/rebase-apply ]; then
        warn "Detected merge/rebase in progress"
        debug "Skipping pre-commit hooks during merge"
        exit 0
    fi
}

check_amend_operation() {
    # Check if this is an amend operation with no staged changes
    # During amend, git diff --cached might show nothing even though files are being committed
    local staged_files
    staged_files=$(git diff --cached --name-only 2>/dev/null | head -1)
    
    # If no files are staged, this might be an amend, empty commit, or error
    if [ -z "$staged_files" ]; then
        # Check if we're in the middle of an amend
        if [ -f ".git/COMMIT_EDITMSG" ] && grep -q "^# Please enter the commit message" ".git/COMMIT_EDITMSG" 2>/dev/null; then
            debug "Possible amend operation detected"
        fi
        
        # For now, if there are no staged files at all, skip the pre-commit
        warn "No files staged for commit"
        debug "Skipping pre-commit hooks (nothing to check)"
        exit 0
    fi
}

show_summary() {
    # Display final summary of all checks with timing and guidance
    # Provides different messages based on success/failure/auto-fixes
    # Returns: 0 if all passed, 1 if any failed
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))

    echo ""
    info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    header "Pre-commit Summary (${DURATION}s)"
    info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [ "$PARTIAL_STAGING_WARNING" -eq 1 ]; then
        echo ""
        warn "Warning: Some files were partially staged"
        debug "Auto-fixes were applied to entire files"
        debug "Review carefully before committing"
    fi

    if [ "$FIXES_APPLIED" -eq 1 ]; then
        echo ""
        warn "Auto-fixes were applied and staged"
        echo ""
        debug "Review the changes:"
        echo "  git diff --cached     # See what will be committed"
        echo "  git diff              # See any remaining unstaged changes"
        echo ""
        debug "Options:"
        echo "  git commit            # Accept fixes and commit"
        echo "  git reset             # Unstage everything to review manually"
        echo "  git reset <file>      # Unstage specific file"
    fi

    if [ "$ERRORS_FOUND" -eq 1 ]; then
        echo ""
        error "Some checks failed and need manual fixes"
        echo ""
        debug "To troubleshoot:"
        echo "  git diff --cached     # Review staged changes"
        echo "  git status            # Check file states"
        echo ""
        debug "To bypass hooks (use sparingly):"
        echo "  git commit --no-verify"
        echo "  touch .git/BYPASS_PRECOMMIT     # For persistent bypass"
        return 1
    else
        echo ""
        success "All checks passed!"
        if [ $QUICK_MODE -eq 1 ]; then
            debug "Note: Quick mode was enabled - some checks were skipped"
        fi
        return 0
    fi
}

run_linters_parallel() {
    # Run all language linters simultaneously for better performance
    # Collects results from all parallel processes
    # Returns: 0 if all passed, 1 if any failed
    
    local pids=""
    local results_dir
    results_dir=$(mktemp -d)
    
    # Ensure results directory was created
    if [ ! -d "$results_dir" ]; then
        error "Failed to create temporary results directory"
        return 1
    fi

    # Start all linters in background
    debug "Running linters in parallel..."

    (
        check_markdown
        echo $? >"$results_dir/markdown"
    ) &
    pids="$pids $!"
    (
        check_typescript
        echo $? >"$results_dir/typescript"
    ) &
    pids="$pids $!"
    (
        check_rust
        echo $? >"$results_dir/rust"
    ) &
    pids="$pids $!"
    (
        check_python
        echo $? >"$results_dir/python"
    ) &
    pids="$pids $!"
    (
        check_shell
        echo $? >"$results_dir/shell"
    ) &
    pids="$pids $!"

    # Wait for all linters to complete
    for pid in $pids; do
        wait "$pid"
    done

    # Aggregate results
    local total_errors=0
    local files_found=0
    
    for result_file in "$results_dir"/*; do
        if [ -f "$result_file" ]; then
            files_found=1
            local exit_code
            exit_code=$(cat "$result_file")
            if [ "$exit_code" -ne 0 ]; then
                total_errors=$((total_errors + 1))
            fi
        fi
    done
    
    # If no result files were created, all checkers must have skipped
    if [ $files_found -eq 0 ]; then
        debug "All checkers skipped (no files to check)"
    fi

    # Clean up
    rm -rf "$results_dir"

    # Return non-zero if any linter failed
    [ $total_errors -eq 0 ]
}

# Main execution
header "Running pre-commit checks..."
debug "Tip: Use PRE_COMMIT_QUICK=1 for faster commits, PRE_COMMIT_SEQUENTIAL=1 for sequential mode"
echo ""

check_merge_conflict
check_amend_operation
activate_venv

# Check if sequential mode is explicitly requested
if [ "$PRE_COMMIT_SEQUENTIAL" = "1" ]; then
    # Run linters sequentially
    check_markdown
    check_typescript
    check_rust
    check_python
    check_shell
else
    # Run linters in parallel (default)
    run_linters_parallel
fi

# Run non-blocking checkers (always sequential)
check_roadmap
check_documentation

# Show summary and exit
show_summary
exit $?
