"""Generate command - Code generation tasks"""

import argparse
import subprocess
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from constants import EXIT_FAILURE, EXIT_SUCCESS
from logger import logger
from utils import SetOnce, find_project_root, run_command

from .core import TaskResult


def generate_api_models(force: bool = False) -> TaskResult:
    """Generate TypeScript types from Rust using ts-rs.

    Args:
        force: Force regeneration even if files are up-to-date

    Returns:
        TaskResult with success status and message
    """
    logger.header("Generating TypeScript API models")

    project_root = find_project_root()
    if not project_root:
        logger.error("Could not find project root")
        return TaskResult(
            success=False,
            message="Could not find project root",
            exit_code=EXIT_FAILURE,
        )

    server_dir = project_root / "server"
    if not server_dir.exists():
        logger.error("Server directory not found")
        logger.info("Make sure you're running this from the project root")
        return TaskResult(
            success=False,
            message="Server directory not found",
            exit_code=EXIT_FAILURE,
        )

    # Discover all Rust files that generate TypeScript types
    source_files = []
    source_sentinels = ["ts_rs", "TS", "export_to"]
    for rust_file in (server_dir / "src").rglob("*.rs"):
        try:
            content = rust_file.read_text()
            if all(sentinel in content for sentinel in source_sentinels):
                source_files.append(rust_file)
        except Exception as e:
            logger.warning(f"Error reading {rust_file}: {e}")
            continue

    if not source_files:
        logger.error("No Rust files with ts-rs derives found")
        return TaskResult(
            success=False,
            message="No Rust files with ts-rs derives found",
            exit_code=EXIT_FAILURE,
        )

    logger.info(f"Found {len(source_files)} source files with ts-rs models")

    # Discover all generated TypeScript files
    generated_files = []
    api_dir = project_root / "extension" / "src" / "api"
    generated_sentinel = "This file was generated by [ts-rs]"
    if api_dir.exists():
        for ts_file in api_dir.rglob("*.ts"):
            try:
                content = ts_file.read_text()
                if generated_sentinel in content:
                    generated_files.append(ts_file)
            except Exception as e:
                logger.warning(f"Error reading {ts_file}: {e}")
                continue

    logger.info(f"Found {len(generated_files)} generated files")

    needs_regeneration = SetOnce[bool]()
    if force:
        needs_regeneration.set(True, "force flag set")
    elif not generated_files:
        needs_regeneration.set(True, "no generated files found")

    # If any of the source files are newer than the generated files, we need to regenerate
    latest_generated_mtime = max(gen_file.stat().st_mtime for gen_file in generated_files)
    for src_file in source_files:
        if src_file.stat().st_mtime > latest_generated_mtime:
            needs_regeneration.set(True, "source files are newer than generated files")
            break

    if not needs_regeneration:
        logger.success("Generated TypeScript files are up-to-date")
        return TaskResult(
            success=True,
            message="Generated TypeScript files are up-to-date",
            exit_code=EXIT_SUCCESS,
        )

    logger.info(f"Generated TypeScript files need updating: {needs_regeneration}")

    # Clean up old generated files, if any
    for gen_file in generated_files:
        if not gen_file.exists():
            continue
        logger.info(f"Removing old generated file: {gen_file}")
        gen_file.unlink()

    # Generate new TypeScript files
    logger.info("Generating TypeScript files from Rust...")

    try:
        run_command(["cargo", "test", "--lib", "--features", "generate-api-models"], cwd=server_dir)

        logger.info("Formatting generated TypeScript files...")
        try:
            run_command(["pnpm", "run", "lint:fix:generated"], cwd=project_root / "extension")
            logger.success("Generated files formatted successfully")
        except Exception as e:
            logger.warning(f"Failed to format generated files: {e}")
            # Don't fail the generation if formatting fails

        return TaskResult(
            success=True,
            message="TypeScript types generated successfully",
            exit_code=EXIT_SUCCESS,
        )
    except Exception as e:
        return TaskResult(
            success=False,
            message=f"Failed to generate TypeScript types: {e}",
            exit_code=EXIT_FAILURE,
        )


def generate_icons(force: bool = False) -> TaskResult:
    """Generate extension icons.

    Args:
        force: Force regeneration even if icons exist

    Returns:
        TaskResult with success status and message
    """
    logger.header("Generating extension icons")
    if force:
        logger.info("Force flag set - regenerating icons")

    project_root = find_project_root()
    if not project_root:
        logger.error("Could not find project root (no .git directory found)")
        return TaskResult(
            success=False,
            message="Could not find project root",
            exit_code=EXIT_FAILURE,
        )

    extension_dir = project_root / "extension"
    if not extension_dir.exists():
        logger.error("Extension directory not found")
        return TaskResult(
            success=False,
            message="Extension directory not found",
            exit_code=EXIT_FAILURE,
        )

    try:
        run_command(["sh", "icons/generate-icons.sh"], cwd=extension_dir)
        logger.success("Icons generated successfully")
        return TaskResult(
            success=True,
            message="Icons generated successfully",
            exit_code=EXIT_SUCCESS,
        )
    except subprocess.CalledProcessError as e:
        logger.error(f"Icon generation failed: {e}")
        return TaskResult(
            success=False,
            message=f"Icon generation failed: {e}",
            exit_code=EXIT_FAILURE,
        )
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return TaskResult(
            success=False,
            message=f"Unexpected error: {e}",
            exit_code=EXIT_FAILURE,
        )


def run(args: argparse.Namespace) -> TaskResult:
    """Main entry point for generate command.

    Args:
        args: Parsed command line arguments containing artifact list and force flag

    Returns:
        TaskResult with success status and message
    """
    artifacts = args.artifact if args.artifact else ["api-models"]
    force = args.force

    results = []
    for artifact in artifacts:
        if artifact == "api-models":
            results.append(generate_api_models(force=force))
        elif artifact == "icons":
            results.append(generate_icons(force=force))
        else:
            results.append(
                TaskResult(
                    success=False,
                    message=f"Unknown artifact: {artifact}",
                    exit_code=EXIT_FAILURE,
                )
            )

    failed = [r for r in results if not r.success]
    if failed:
        return TaskResult(
            success=False,
            message=f"Generation failed: {'; '.join(r.message for r in failed)}",
            exit_code=EXIT_FAILURE,
        )

    return TaskResult(
        success=True,
        message=f"Successfully generated: {', '.join(artifacts)}",
        exit_code=EXIT_SUCCESS,
    )


def add_subparser(subparsers: argparse._SubParsersAction) -> None:
    """Add the generate subcommand to the parser.

    Args:
        subparsers: The subparsers object from argparse
    """
    parser: argparse.ArgumentParser = subparsers.add_parser(
        "generate",
        aliases=["gen"],
        help="Code generation tasks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  tanaka generate                # Generate TypeScript API models (default)
  tanaka generate api-models     # Generate TypeScript API models
  tanaka generate icons          # Generate extension icons
  tanaka gen api-models icons    # Generate both
  tanaka generate --force        # Force regeneration even if up-to-date
        """,
    )
    parser.add_argument(
        "artifact",
        nargs="*",
        choices=["api-models", "icons"],
        help="Artifact(s) to generate (default: api-models)",
    )
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force regeneration even if files are up-to-date",
    )
    parser.set_defaults(func=run)
