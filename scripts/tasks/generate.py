"""Generate command - Code generation tasks"""

import argparse
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from constants import EXIT_FAILURE, EXIT_SUCCESS
from logger import logger
from utils import SetOnce, check_command, find_extension_dir, find_server_dir, run_command

from .core import TaskResult


def _find_source_files(paths_to_search: Path | list[Path]) -> list[Path]:
    sentinels = ["ts_rs", "TS", "export_to"]
    source_files = []
    if isinstance(paths_to_search, Path):
        paths_to_search = [paths_to_search]
    for path in paths_to_search:
        for file in path.rglob("**/*.rs"):
            try:
                content = file.read_text()
                if all(sentinel in content for sentinel in sentinels):
                    source_files.append(file)
            except Exception as e:
                logger.warning(f"Error reading {file}: {e}")
                continue

    return source_files


def _find_generated_files(paths_to_search: Path | list[Path]) -> list[Path]:
    sentinel = "This file was generated by [ts-rs]"
    generated_files = []
    if isinstance(paths_to_search, Path):
        paths_to_search = [paths_to_search]
    for path in paths_to_search:
        for file in path.rglob("**/*.ts"):
            try:
                content = file.read_text()
                if sentinel in content:
                    generated_files.append(file)
            except Exception as e:
                logger.warning(f"Error reading {file}: {e}")
                continue

    return generated_files


def generate_api_models(force: bool = False) -> TaskResult:
    logger.header("Generating TypeScript API models")

    server_dir = find_server_dir()
    if not server_dir or not server_dir.exists():
        logger.error("Could not find server directory")
        return TaskResult(
            success=False,
            message="Could not find server directory",
            exit_code=EXIT_FAILURE,
        )

    source_files = _find_source_files(server_dir / "src")
    if not source_files:
        logger.error("No Rust files with ts-rs derives found")
        return TaskResult(
            success=False,
            message="No Rust files with ts-rs derives found",
            exit_code=EXIT_FAILURE,
        )
    logger.info(f"Found {len(source_files)} Rust source files with ts-rs models")

    needs_regeneration = SetOnce[bool]()
    if force:
        needs_regeneration.set(True, "force flag set")

    extension_dir = find_extension_dir()
    if not extension_dir or not extension_dir.exists():
        logger.error("Could not find extension directory")
        return TaskResult(
            success=False,
            message="Could not find extension directory",
            exit_code=EXIT_FAILURE,
        )
    generated_files = _find_generated_files(extension_dir / "src" / "api")
    logger.info(f"Found {len(generated_files)} TypeScript generated files")

    if not generated_files:
        needs_regeneration.set(True, "no generated files found")
    else:
        # If any of the source files are newer than the generated files, we need to regenerate
        latest_generated_mtime = max(gen_file.stat().st_mtime for gen_file in generated_files)
        for src_file in source_files:
            if src_file.stat().st_mtime > latest_generated_mtime:
                needs_regeneration.set(True, "source files are newer than generated files")
                break

    if not needs_regeneration.get():
        logger.success("Generated TypeScript files are up-to-date")
        return TaskResult(
            success=True,
            message="Generated TypeScript files are up-to-date",
            exit_code=EXIT_SUCCESS,
        )

    logger.info(f"Generated TypeScript files need updating: {needs_regeneration.reason}")

    for gen_file in generated_files:
        if not gen_file.exists():
            continue
        logger.info(f"Removing old generated file: {gen_file}")
        gen_file.unlink()

    logger.info("Generating TypeScript files from Rust...")

    try:
        run_command(["cargo", "test", "--lib", "--features", "generate-api-models"], cwd=server_dir)

        logger.info("Formatting generated TypeScript files...")
        try:
            run_command(
                ["pnpm", "run", "lint:specific", "--", "src/api/**/*.ts"],
                cwd=extension_dir,
            )
            logger.success("Generated files formatted successfully")
        except Exception as e:
            logger.warning(f"Failed to format generated files: {e}")
            # Don't fail the generation if formatting fails

        return TaskResult(
            success=True,
            message="TypeScript types generated successfully",
            exit_code=EXIT_SUCCESS,
        )
    except Exception as e:
        return TaskResult(
            success=False,
            message=f"Failed to generate TypeScript types: {e}",
            exit_code=EXIT_FAILURE,
        )


def generate_ext_icons(force: bool = False) -> TaskResult:
    logger.header("Generating extension icons")

    extension_dir = find_extension_dir()
    if not extension_dir or not extension_dir.exists():
        logger.error("Could not find extension directory")
        return TaskResult(
            success=False,
            message="Could not find extension directory",
            exit_code=EXIT_FAILURE,
        )

    icons_dir = extension_dir / "icons"
    icons_dir.mkdir(exist_ok=True)

    # Check if icons already exist
    sizes = [16, 32, 48, 128]
    icon_files = [icons_dir / f"icon-{size}.png" for size in sizes]
    icon_files.append(icons_dir / "icon.svg")
    removed_count = 0
    for icon_file in icon_files:
        if icon_file.exists():
            logger.debug(f"Removing existing {icon_file.name}")
            icon_file.unlink()
            removed_count += 1

    if removed_count > 0:
        logger.info(f"Removed {removed_count} existing icons")

    svg_content = """<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
  <rect width="128" height="128" fill="#4A90E2" rx="16"/>
  <text x="50%" y="70%" font-family="Arial, sans-serif" font-size="72" font-weight="bold"
        fill="white" text-anchor="middle" dominant-baseline="middle">T</text>
</svg>"""

    # Check if ImageMagick is available
    if not check_command("convert"):
        logger.error("ImageMagick 'convert' command not found")
        logger.info("Install with: brew install imagemagick (macOS) or apt-get install imagemagick (Linux)")
        return TaskResult(
            success=False,
            message="ImageMagick 'convert' command not found",
            exit_code=EXIT_FAILURE,
        )

    try:
        svg_path = icons_dir / "icon.svg"
        svg_path.write_text(svg_content)
        logger.info("Created SVG icon")

        for size in sizes:
            png_path = icons_dir / f"icon-{size}.png"

            run_command(["convert", str(svg_path), "-resize", f"{size}x{size}", str(png_path)])

            if not png_path.exists():
                logger.error(f"  {png_path.name} could not be generated")
                return TaskResult(
                    success=False,
                    message=f"Extension icon {png_path.name} could not be generated",
                    exit_code=EXIT_FAILURE,
                )

            logger.info(f"Generated {size}x{size} PNG icon")

        logger.success("Extension icons generated successfully")
        return TaskResult(
            success=True,
            message="Extension icons generated successfully",
            exit_code=EXIT_SUCCESS,
        )
    except Exception as e:
        logger.error(f"Failed to generate extension icons: {e}")
        return TaskResult(
            success=False,
            message=f"Failed to generate extension icons: {e}",
            exit_code=EXIT_FAILURE,
        )


def run(args: argparse.Namespace) -> TaskResult:
    artifacts = args.artifact if args.artifact else ["api-models"]

    results = []
    for artifact in artifacts:
        if artifact == "api-models":
            results.append(generate_api_models(force=args.force))
        elif artifact == "ext-icons":
            results.append(generate_ext_icons(force=args.force))
        else:
            results.append(
                TaskResult(
                    success=False,
                    message=f"Unknown artifact: {artifact}",
                    exit_code=EXIT_FAILURE,
                )
            )

    failed = [r for r in results if not r.success]
    if failed:
        return TaskResult(
            success=False,
            message=f"Generation failed: {'; '.join(r.message for r in failed)}",
            exit_code=EXIT_FAILURE,
        )

    return TaskResult(
        success=True,
        message=f"Successfully generated: {', '.join(artifacts)}",
        exit_code=EXIT_SUCCESS,
    )


def add_subparser(subparsers: argparse._SubParsersAction) -> None:
    parser: argparse.ArgumentParser = subparsers.add_parser(
        "generate",
        aliases=["gen"],
        help="Code generation tasks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  tanaka generate                   # Generate TypeScript API models (default)
  tanaka generate api-models        # Generate TypeScript API models
  tanaka generate ext-icons         # Generate extension icons
  tanaka gen api-models ext-icons   # Generate both
  tanaka generate --force           # Force regeneration even if up-to-date
        """,
    )
    parser.add_argument(
        "artifact",
        nargs="*",
        choices=["api-models", "ext-icons"],
        help="Artifact(s) to generate (default: api-models)",
    )
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force regeneration even if files are up-to-date",
    )
    parser.set_defaults(func=run)
