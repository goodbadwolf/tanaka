"""Generate command - Code generation tasks"""

import argparse
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))
from constants import EXIT_FAILURE, EXIT_SUCCESS
from logger import logger
from utils import find_project_root, run_command

from .core import TaskResult


def generate_api_models() -> TaskResult:
    """Generate TypeScript types from Rust using ts-rs"""
    logger.header("Generating TypeScript API models")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        logger.error("Could not find project root (no .git directory found)")
        return TaskResult(
            success=False,
            message="Could not find project root",
            exit_code=EXIT_FAILURE,
        )

    server_dir = project_root / "server"
    if not server_dir.exists():
        logger.error("Server directory not found")
        logger.info("Make sure you're running this from the project root")
        return TaskResult(
            success=False,
            message="Server directory not found",
            exit_code=EXIT_FAILURE,
        )

    # Check if generated models are stale
    # Check multiple source files that generate TypeScript
    source_files = [server_dir / "src" / "models.rs", server_dir / "src" / "error.rs", server_dir / "src" / "sync.rs"]

    # Check multiple generated directories
    generated_files = [
        project_root / "extension" / "src" / "api" / "models" / "Tab.ts",
        project_root / "extension" / "src" / "api" / "errors" / "ErrorCode.ts",
        project_root / "extension" / "src" / "api" / "sync" / "SyncRequest.ts",
    ]

    # Check if all source files exist
    for src_file in source_files:
        if not src_file.exists():
            logger.error(f"Source file not found: {src_file}")
            return TaskResult(success=False, message=f"Source file not found: {src_file}", exit_code=EXIT_FAILURE)

    # Check if regeneration is needed
    needs_regeneration = False
    latest_source_mtime = max(src.stat().st_mtime for src in source_files)

    # Check if any generated file is missing or older than source
    for gen_file in generated_files:
        if not gen_file.exists():
            needs_regeneration = True
            break
        if gen_file.stat().st_mtime < latest_source_mtime:
            needs_regeneration = True
            break

    if not needs_regeneration:
        logger.success("Generated TypeScript files are up-to-date")
        return TaskResult(
            success=True,
            message="Generated TypeScript files are up-to-date",
            exit_code=EXIT_SUCCESS,
        )

    # Show why regeneration is needed
    from datetime import datetime

    latest_source_time = datetime.fromtimestamp(latest_source_mtime)
    logger.warning("Generated TypeScript files need updating...")
    logger.info(f"Latest source file date: {latest_source_time.strftime('%Y-%m-%d %H:%M:%S')}")

    # Clean up old generated files in all directories
    generated_dirs = [
        project_root / "extension" / "src" / "api" / "models",
        project_root / "extension" / "src" / "api" / "errors",
        project_root / "extension" / "src" / "api" / "sync",
    ]

    for gen_dir in generated_dirs:
        if gen_dir.exists():
            logger.info(f"Cleaning {gen_dir.name} directory...")
            for ts_file in gen_dir.glob("*.ts"):
                if "This file was generated by [ts-rs]" in ts_file.read_text():
                    ts_file.unlink()
        else:
            gen_dir.mkdir(parents=True, exist_ok=True)

    # Generate new TypeScript files
    logger.info("Generating TypeScript files from Rust...")

    try:
        run_command(["cargo", "test", "--lib", "--features", "generate-api-models"], cwd=server_dir)

        # Run the linter on generated files
        logger.info("Formatting generated TypeScript files...")
        extension_dir = project_root / "extension"
        try:
            run_command(["pnpm", "run", "lint:fix:generated"], cwd=extension_dir)
            logger.success("Generated files formatted successfully")
        except Exception as e:
            logger.warning(f"Failed to format generated files: {e}")
            # Don't fail the generation if formatting fails

        return TaskResult(
            success=True,
            message="TypeScript types generated successfully",
            exit_code=EXIT_SUCCESS,
        )
    except Exception as e:
        return TaskResult(
            success=False,
            message=f"Failed to generate TypeScript types: {e}",
            exit_code=EXIT_FAILURE,
        )


def run(args: argparse.Namespace) -> TaskResult:
    """Main entry point for generate command"""
    if args.artifact == "api-models":
        return generate_api_models()
    else:
        return TaskResult(
            success=False,
            message=f"Unknown artifact: {args.artifact}",
            exit_code=EXIT_FAILURE,
        )


def add_subparser(subparsers: argparse._SubParsersAction) -> None:
    """Add the generate subcommand to the parser"""
    parser: argparse.ArgumentParser = subparsers.add_parser(
        "generate",
        aliases=["gen"],
        help="Code generation tasks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  tanaka generate                # Generate TypeScript API models (default)
  tanaka generate api-models     # Generate TypeScript API models
  tanaka gen                     # Short alias for generate
        """,
    )
    parser.add_argument(
        "artifact",
        nargs="?",
        default="api-models",
        choices=["api-models"],
        help="Artifact to generate (default: api-models)",
    )
    parser.set_defaults(func=run)
